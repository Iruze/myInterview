# 什么是python的鸭子类型：
- Ref: [python ducking](https://blog.csdn.net/qq_18824345/article/details/105786417)

1. “当你看到一只鸟走起来像鸭子，游泳起来鸭子，叫起来也像鸭子，那么这只鸟就被称为鸭子类型“
2. 鸭子类型是多态一种形式，这这种形式中，不管对象属于哪个类，也不管声明的具体接口是什么，只要对象实现了相应的方法，函数就可以在对象上执行操作。

```python3
def func(obj):
    obj.who()

if __name__ == "__main__":
    duck=Duck()
    dog=Dog()
    cat=Cat()
    func(duck)
    func(dog)
    func(cat)
    
"""output    
I am a duck
I am a dog
I am a cat
"""
```
定义一个函数func()，这个函数对参数有一个要求，
那就是参数必须有who()这个方法。不管你是什么对象，
是duck对象也好，是dog对象也罢，只管对象实现who()方法就可。
这就是鸭子类型，它根本不管你是什么对象，只要你有这个方法，有这个行为，
表现得像鸭子，走起来像鸭子，游泳起来鸭子，叫起来也像鸭子，
那么尽管你是一只会飞天的猪，也是称为鸭子类型。

# c++中的抽象基类




# c++多态
Ref: [C++---静态多态与动态多态](https://blog.csdn.net/qq_37934101/article/details/81365449)

定义：多种形态，相同的方法调用，但是有不同的实现方式，不同的结果
分类：
- 静态多态（编译期多态）
- 动态多态（运行期多态）

### 静态多态
编译器在编译期间完成的，编译器根据函数实参的类型(可能会进行隐式类型转换)，
可推断出要调用那个函数，如果有对应的函数就调用该函数，否则出现编译错误。

**实现方式：**
> 函数重载：普通函数 & 成员函数
>
> 模板

函数重载： 相同的函数名(运算符),不同的参数列表(参数类型，顺序，个数)， 跟返回值无关。
```c++
// print()函数重载
void print(const char* str,int width);
void print(double i ,int width);
void print(const char* str);

// 以下重载是错误的
// 重载时返回值可以不同，但参数列表必须不同
void print(const char* str,int width);
int print(const char* str,int width);
```

函数模板：使用泛型来定义函数，通过将类型作为参数，传递给模板，可使编译器生成该类型的函数。
```c++
// 交换两个值，但是不清楚是int 还是 double，如果不使用模板，则要写两份代码
// 使用函数模板，将类型作为参数传递
template<class T>
class Swa(T a,T b)
{
    T temp;
    temp = a;
    a = b;
    b = temp;
};

```

### 动态多态
在程序执行期间(非编译期)判断所引用对象的实际类型，
根据其实际类型调用相应的方法。

实现方式：
> 通过基类类型的引用或指针调用虚函数

静态类型 VS 动态类型
```shell script
静态类型：对象声明时的类型，编译时确定

动态类型：目前所指对象的类型，运行时确定
```

```c++
class Cat: public Animal
{};

class Dog: public Animal
{};

int main()
{
    Cat* c1 = new Cat;       // c1的静态类型是Cat, 动态类型也是Cat
    Animal a1 = c1;          // a1的静态类型是Animal, 动态类型是Cat
    Dog d1 = new Dog;
    a1 = d1;                 // a1的动态类型是Dog
}
```

**区别： 重载 vs 重写**
```shell script
      | 在同一作用域
重载   | 函数名相同，参数列表必须不同
      | 返回值可以不同

      | 不同的作用域：基类 vs 派生类
重写   | 函数名，参数列表，返回值，都要相同
      | 基类函数必须有virtual关键字
      | 访问修饰符可以不同
```

# c++虚函数
Ref: 

[C++ 虚函数、纯虚函数](https://zhuanlan.zhihu.com/p/37331092)
[C++多态——静态多态与动态多态](https://blog.csdn.net/stay_the_course/article/details/55259801)

- 虚函数，在类成员方法的声明（不是定义）语句前加“virtual”, 如 virtual void func()
- 纯虚函数，在虚函数后加“=0”，如 virtual void func()=0
- 对于虚函数，子类可以（也可以不）重新定义基类的虚函数，该行为称之为复写Override。
- 对于纯虚函数，子类必须提供纯虚函数的个性化实现。

在派生子类中对虚函数和纯虚函数的个性化实现，都体现了“多态”特性。但区别是：

- 子类如果不提供虚函数的实现，将会自动调用基类的缺省虚函数实现，作为备选方案；
子类如果不提供纯虚函数的实现，编译将会失败。
尽管在基类中可以给出纯虚函数的实现，
但无法通过指向子类对象的基类类型指针来调用该纯虚函数，
也即不能作为子类相应纯虚函数的备选方案。
（纯虚函数在基类中的实现跟多态性无关，它只是提供了一种语法上的便利，
在变化多端的应用场景中留有后路。）

### c++类的成员函数在定义对象前分配了存储空间吗？
> 对于一般的类(非静态)来说，在定义类但还未创建对象的时候，
>类的所有成员(包括变量和函数)都占用着内存空间(准确地说占用着指令代码区)，
>但不占用堆栈空间

> 而创建对象的时候，会根据对象的类型占用堆栈的空间(用传统模式创建对象会占用栈空间，
>用引用+new模式创建对象会占用堆空间，同时引用会保存在栈里)

> 对于静态(static)类来说，静态类是不能实例化创建对象的，
>所有的成员都是静态成员，也需要占用内存空间，但不在堆栈里，
>而是在内存的**静态/全局区**(这个区域用于存放所有的全局成员和静态成员)。
而创建对象的时候，会根据对象的类型占用堆栈的空间(用传统模式创建对象会占用栈空间，用引用+new模式创建对象会占用堆空间，同时引用会保存在栈里)

### 虚函数底层实现原理
Ref:

- [虚函数的作用及其底层实现机制](https://blog.csdn.net/iFuMI/article/details/51088091#commentBox)

- [底层实现原理：先来看看C++对象模型](https://www.nowcoder.com/questionTerminal/1f67d4e2b6134c298e993e622181b333)

**实现原理：虚函数表+虚表指针**

**关键字**：虚函数底层实现机制；虚函数表；虚表指针

编译器处理虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针（vptr），这种数组成为虚函数表（virtual function table, vtbl），即，**每个类使用一个虚函数表，每个类对象用一个虚表指针。**

举个例子：基类对象包含一个虚表指针，指向基类中所有虚函数的地址表。派生类对象也将包含一个虚表指针，指向派生类虚函数表。看下面两种情况：

如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数的地址，而不是基类的虚函数地址。

如果基类中的虚方法没有在派生类中重写，那么派生类将继承基类中的虚方法，而且派生类中虚函数表将保存基类中未被重写的虚函数的地址。注意，如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中。

多态体现：动态编译过程中，通过一系列的**指针解引用**找到派生类override的虚函数。

ps: 通过基类的引用或指针调用，调用基类还是派生类的虚函数，
要根据运行时根据指针或引用实际指向或引用的类型确定，调用非虚函数时，
则无论基类指向的是何种类型，都调用基类的函数


### 析构函数和构造函数能够是虚函数吗？
> 答案是：构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。

首先，我们已经知道虚函数的实现则是通过对象内存中的vptr来实现的。
而构造函数是用来实例化一个对象的，通俗来讲就是为对象内存中的值做初始化操作。
那么在构造函数完成之前，也即还没有进行初始化，此时vptr是没有值的，
也就无法通过vptr找到作为构造函数和虚函数所在的代码区，
所以构造函数只能以普通函数的形式存放在类所指定的代码区中。

而对于析构函数，当我们delete(a)的时候，如果析构函数不是虚函数，
那么调用的将会是基类base的析构函数。而当继承的时候，
通常派生类会在基类的基础上定义自己的成员，
此时我们当然希望可以调用派生类的析构函数对新定义的成员也进行析构。

Ref:

[构造函数和析构函数可以是虚函数吗？](https://zhuanlan.zhihu.com/p/37331092)


# 指针和引用的区别
Ref: [指针vs引用](https://www.cnblogs.com/dolphin0520/archive/2011/04/03/2004869.html)

- 指针是一个变量，存储指向变量的内存单元/地址； 引用是原来变量的别名
- 有const指针，不存在const应用
- 指针有多级，*p, **p， 引用只能是一级, &a（&&a不合法）
- 指针可以为NULL, 引用不能，定义时候必须初始化
- 指针初始化后可以改变(指向其他的存储单元), 引用定义后不能改变
- "sizeof指针"-指针本身的大小， "sizeof引用"-指向变量的实际大小
> 
- 指针和引用自增(++)运算意义不同

#### 指向常量的指针 vs 常指针
参考： [常指针和指向常量的指针的区别](https://blog.csdn.net/zhanghuaichao/article/details/52779572)

> 指向常量的指针： 指针指向的对象为常量，但指针可以改变指向(地址)
```
// 指向常量的指针
const char *p;

char const *p;
```

> 常指针： 指针的值为常量，即指针指向的位置不变，但指向的对象值可以改变
```
// 常指针
char * const p;
```

# c/c++中数据类型占用字节数
参考：

[C/C++中基本数据类型所占内存大小](https://blog.csdn.net/zcyzsy/article/details/77935651)

[C/C++ 各数据类型占用字节数](https://zhuanlan.zhihu.com/p/93583960)

C/C++ 在32bit & 64bit编译器下各数据类型字节数
```shell script
                      32bit             64bit
char                    1                 1

short int               2                 2

unsigned int/int        4                 4

float                   4                 4

double                  8                 8

unsigned long/long      4                 8      
long int

long long               8                 8
long long int

point                   4                 8
````
ps: 编译器位数和类型大小没关系

类型大小是目标平台决定的

一般是编译器通过编译参数指定一个目标平台



#### 其他：

[GPU 和显卡是什么关系？](https://www.zhihu.com/search?type=content&q=%E6%98%BE%E5%8D%A1%E5%92%8Cgpu%E7%9A%84%E5%8C%BA%E5%88%AB)

[java虚拟机&字节码vs机器码](https://zhuanlan.zhihu.com/p/44657693)
























