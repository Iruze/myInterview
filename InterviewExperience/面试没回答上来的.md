- 什么是tcp粘包, 产生的原因和如何解决 (腾讯一面)

[TCP粘包和拆包](https://www.jianshu.com/p/9e3cefc21ca9)

[tcp的拆包和粘包](https://zhuanlan.zhihu.com/p/77275039)

- 基类的析构函数为什么要定义为虚函数        
> 当基类指针指向派生类的时候，若基类析构函数不声明为虚函数，在析构时，只会调用基类而不会调用派生类的析构函数，从而导致内存泄露。       
    [C++：基类析构函数为什么要定义为虚函数](https://blog.csdn.net/ENSHADOWER/article/details/96481661)    

- 析构函数为什么不能重载     
> 析构函数只能有一个, 且不能带有参数和返回值, 属于系统自动调用, 不能重载      
    [C++之类的析构函数](https://www.cnblogs.com/MrListening/p/5567762.html)

- 拷贝构造函数为什么要用引用
> 在执行bbb.myTestFunc(aaa);时，其实会调用拷贝构造函数。如果我们的拷贝构造函数的参数不是引用，那么在bbb.myTestFunc(aaa);时，调用CExample ex = aaa;，又因为ex之前没有被创建，所以又需要调用拷贝构造函数，故而又执行CExample ex = aaa;，就这样永远的递归调用下去了。               
     [c++拷贝构造函数（为什么要用const，参数为什么用引用）](https://blog.csdn.net/ypshowm/article/details/89245958)


- linux shell中常用的面试题            
    [70个经典的 Shell 脚本面试问题](https://www.cnblogs.com/jjzd/p/6014301.html)    
    [二、运维岗linux面试题收集](https://blog.csdn.net/weixin_51432770/article/details/114543546)    
    [Shell脚本面试题Top50](https://www.jianshu.com/p/7a08d193cf79)    
    [算法工程师的修养 | 必会的24道Shell脚本面试题](https://my.oschina.net/u/4579551/blog/4981214)    


### python中import和monkey patch
- import <package> 发生了什么?       
``` 
•导入一个module
•将module对象加入到sys.modules，后续对该module的导入将直接从该dict中获得
•将module对象加入到globals dict中
    
一个python程序一个进程空间, 所有的package在import之后都会缓存在内存中, 并用sys.modules这个字典表示.
第二次import相同的package, 只会从sys.modules中查找
```

例如:
```python
>>> import sys
>>> type(sys.modules)
<class 'dict'>
>>> sys.modules.__len__()
169
>>> 'json' in sys.modules
False

>>> import json
>>> sys.modules.__len__()
174
>>> 'json' in sys.modules
True
```


将`json`更换为`ujson`的monkey patch, 只需要在**进程入口**patch上
```python

import json
import ujson
def monkey_patch_json():
    json.__name__ = 'ujson'
    json.dumps = ujson.dumps
    json.loads = ujson.loads
```
这样, 在内存变量`sys.modules`中记录的`json`就是`ujson`了.     

<details>  
    <summary>注意</summary>
    
这里只是需要替换掉`dumps`和`loads`这两个方法, 如果需要替换更多的方法, 需要依次替换

```python
>>> sys.modules['json']
<module 'json' from '/usr/lib/python3.6/json/__init__.py'>
>>> type(sys.modules['json'])
<class 'module'>
```

```shell
peter@peter1970:/usr/lib/python3.6/json$ pwd
/usr/lib/python3.6/json
peter@peter1970:/usr/lib/python3.6/json$ grep -rn 'def dumps'
__init__.py:183:def dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True,
```

`loads`是deserialize功能
```python
def loads(s, *, encoding=None, cls=None, object_hook=None, parse_float=None,
        parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):
    """Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance
    containing a JSON document) to a Python object.
```

`dumps`是serialize功能
```python
def dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True,
        allow_nan=True, cls=None, indent=None, separators=None,
        default=None, sort_keys=False, **kw):
    """Serialize ``obj`` to a JSON formatted ``str``.
```
</details>
