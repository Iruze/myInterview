# lru的原理和实现
- [面试题 16.25. LRU缓存](https://leetcode-cn.com/problems/lru-cache-lcci/)
- [146. LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)

定义:
<details>
<summary>展开</summary>
"最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。

它应该支持以下操作： 获取数据 `get` 和 写入数据 `put` 。

获取数据 `get(key)` - 如果密钥 `(key)` 存在于缓存中，则获取密钥的值（总是正数），否则返回 `-1`。

写入数据 `put(key, value)` - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。
</details>

如何实现？
<details>
<summary>展开</summary>

- [python OrderedDict 详解](https://blog.csdn.net/bell10027/article/details/80940260)　　　　　

比如python中的`OrderedDict`数据结构，实现是一个循环双向链表＋哈希表。

当一个`put`一个链表中不存在的元素时，直接加入到链表尾部；       
当`put`或者`get`访问一个已经在链表的元素的时候，将该元素的节点移动到链表尾部，元素原来两段的节点拼接在一起；         
当链表超出链表的容量的时候，直接移除链表头部，从而实现删除最近最少项目。

`OrderedDict`类的内部方法`self.__map[key]`实现了`key`个链表指针的哈希映射，从而实现了在`lru`的`O(1)`查询时间复杂度。
</details>
